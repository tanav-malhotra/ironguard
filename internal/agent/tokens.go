package agent

import (
	"sync"
)

// ModelPricing contains pricing info for an LLM model (per 1M tokens).
type ModelPricing struct {
	InputPer1M  float64 // Cost per 1M input tokens
	OutputPer1M float64 // Cost per 1M output tokens
}

// ModelPricingMap contains pricing for known models (USD per 1M tokens).
// Prices are approximate and may vary. Updated Dec 2024.
var ModelPricingMap = map[string]ModelPricing{
	// Claude models
	"claude-opus-4-5":   {InputPer1M: 15.00, OutputPer1M: 75.00},
	"claude-sonnet-4-5": {InputPer1M: 3.00, OutputPer1M: 15.00},
	// OpenAI models (hypothetical GPT-5.1 pricing, based on trends)
	"gpt-5.1":           {InputPer1M: 10.00, OutputPer1M: 30.00},
	"gpt-5.1-codex-max": {InputPer1M: 10.00, OutputPer1M: 30.00},
	// Gemini models
	"gemini-3-pro-preview": {InputPer1M: 7.00, OutputPer1M: 21.00},
	"gemini-3-pro":         {InputPer1M: 7.00, OutputPer1M: 21.00},
	// Local models (free)
	"local": {InputPer1M: 0.00, OutputPer1M: 0.00},
}

// GetModelPricing returns pricing for a model, with fallback to defaults.
func GetModelPricing(model string) ModelPricing {
	if pricing, ok := ModelPricingMap[model]; ok {
		return pricing
	}
	// Default fallback pricing
	return ModelPricing{InputPer1M: 5.00, OutputPer1M: 15.00}
}

// TokenUsage tracks token usage for the session.
type TokenUsage struct {
	mu sync.RWMutex
	
	// Current context
	InputTokens  int // Tokens in current context (messages)
	OutputTokens int // Tokens generated by AI in current turn
	
	// Session totals
	TotalInputTokens  int // Total input tokens used this session
	TotalOutputTokens int // Total output tokens used this session
	
	// Subagent totals (tracked separately)
	SubagentInputTokens  int // Total input tokens from subagents
	SubagentOutputTokens int // Total output tokens from subagents
	
	// Cost tracking
	CurrentModel     string  // Current model for pricing
	TotalCostUSD     float64 // Total estimated cost in USD
	SubagentCostUSD  float64 // Cost from subagents
	
	// Summarization stats
	TokensSavedBySummary int // Tokens saved by summarization
	SummaryCount         int // Number of times context was summarized
	
	// Model context limits (approximate)
	ContextLimit int // Max context window for current model
}

// NewTokenUsage creates a new token usage tracker.
func NewTokenUsage() *TokenUsage {
	return &TokenUsage{
		ContextLimit: 200000, // Default to 200K (Claude's limit)
		CurrentModel: "claude-opus-4-5",
	}
}

// SetContextLimit sets the context limit for the current model.
func (t *TokenUsage) SetContextLimit(limit int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.ContextLimit = limit
}

// SetModel sets the current model for pricing calculations.
func (t *TokenUsage) SetModel(model string) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.CurrentModel = model
}

// AddInput records input tokens used and updates cost.
func (t *TokenUsage) AddInput(tokens int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.InputTokens = tokens
	t.TotalInputTokens += tokens
	
	// Calculate cost
	pricing := GetModelPricing(t.CurrentModel)
	cost := float64(tokens) / 1_000_000.0 * pricing.InputPer1M
	t.TotalCostUSD += cost
}

// AddOutput records output tokens generated and updates cost.
func (t *TokenUsage) AddOutput(tokens int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.OutputTokens += tokens
	t.TotalOutputTokens += tokens
	
	// Calculate cost
	pricing := GetModelPricing(t.CurrentModel)
	cost := float64(tokens) / 1_000_000.0 * pricing.OutputPer1M
	t.TotalCostUSD += cost
}

// AddSubagentUsage records tokens used by a subagent.
func (t *TokenUsage) AddSubagentUsage(inputTokens, outputTokens int, model string) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.SubagentInputTokens += inputTokens
	t.SubagentOutputTokens += outputTokens
	
	// Calculate subagent cost
	pricing := GetModelPricing(model)
	inputCost := float64(inputTokens) / 1_000_000.0 * pricing.InputPer1M
	outputCost := float64(outputTokens) / 1_000_000.0 * pricing.OutputPer1M
	subCost := inputCost + outputCost
	t.SubagentCostUSD += subCost
	t.TotalCostUSD += subCost
}

// RecordSummary records that a summarization occurred.
func (t *TokenUsage) RecordSummary(tokensSaved int) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.TokensSavedBySummary += tokensSaved
	t.SummaryCount++
}

// GetCurrentContext returns current context token count.
func (t *TokenUsage) GetCurrentContext() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.InputTokens
}

// GetSessionTotal returns total tokens used this session.
func (t *TokenUsage) GetSessionTotal() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.TotalInputTokens + t.TotalOutputTokens
}

// GetStats returns all token statistics.
func (t *TokenUsage) GetStats() TokenStats {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return TokenStats{
		CurrentContext:        t.InputTokens,
		ContextLimit:          t.ContextLimit,
		ContextPercentage:     float64(t.InputTokens) / float64(t.ContextLimit) * 100,
		TotalInputTokens:      t.TotalInputTokens,
		TotalOutputTokens:     t.TotalOutputTokens,
		TotalTokens:           t.TotalInputTokens + t.TotalOutputTokens,
		SubagentInputTokens:   t.SubagentInputTokens,
		SubagentOutputTokens:  t.SubagentOutputTokens,
		SubagentTotalTokens:   t.SubagentInputTokens + t.SubagentOutputTokens,
		TotalCostUSD:          t.TotalCostUSD,
		SubagentCostUSD:       t.SubagentCostUSD,
		MainAgentCostUSD:      t.TotalCostUSD - t.SubagentCostUSD,
		CurrentModel:          t.CurrentModel,
		TokensSavedBySummary:  t.TokensSavedBySummary,
		SummaryCount:          t.SummaryCount,
	}
}

// Reset resets the session token counts.
func (t *TokenUsage) Reset() {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.InputTokens = 0
	t.OutputTokens = 0
	t.TotalInputTokens = 0
	t.TotalOutputTokens = 0
	t.SubagentInputTokens = 0
	t.SubagentOutputTokens = 0
	t.TotalCostUSD = 0
	t.SubagentCostUSD = 0
	t.TokensSavedBySummary = 0
	t.SummaryCount = 0
}

// TokenStats contains token usage statistics.
type TokenStats struct {
	CurrentContext       int     // Current context size in tokens
	ContextLimit         int     // Maximum context window
	ContextPercentage    float64 // Percentage of context used
	TotalInputTokens     int     // Total input tokens this session (main agent)
	TotalOutputTokens    int     // Total output tokens this session (main agent)
	TotalTokens          int     // Total tokens (input + output) (main agent)
	SubagentInputTokens  int     // Total input tokens from subagents
	SubagentOutputTokens int     // Total output tokens from subagents
	SubagentTotalTokens  int     // Total tokens from subagents
	TotalCostUSD         float64 // Total estimated cost in USD (main + subagents)
	SubagentCostUSD      float64 // Cost from subagents only
	MainAgentCostUSD     float64 // Cost from main agent only
	CurrentModel         string  // Current model name
	TokensSavedBySummary int     // Tokens saved by summarization
	SummaryCount         int     // Number of summarizations
}

// EstimateTokens estimates token count from text (rough: ~4 chars per token).
func EstimateTokens(text string) int {
	return len(text) / 4
}

// EstimateTokensAccurate provides a slightly more accurate estimate.
// Uses ~3.5 chars per token for English text.
func EstimateTokensAccurate(text string) int {
	// Count words and characters
	words := 0
	inWord := false
	for _, c := range text {
		if c == ' ' || c == '\n' || c == '\t' {
			if inWord {
				words++
				inWord = false
			}
		} else {
			inWord = true
		}
	}
	if inWord {
		words++
	}
	
	// Tokens are roughly: words * 1.3 (accounting for subword tokenization)
	// But also account for special characters and whitespace
	return int(float64(words)*1.3) + len(text)/20
}

